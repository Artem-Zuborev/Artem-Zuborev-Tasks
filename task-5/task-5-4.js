1 - '0' + 2 => 1 - 0 + 2 = 3;
1 - '-0' + 2 => 1 - 0 + 2 = 3;
1 - '-0-' + 'NaN' => 1 - '-0-' = Nan => NaN - NaN = NaN;


'b' + [NaN + 'ba', 'CC'] - {};
// В массиве NaN приводится к строке => ['NaNba', 'CC']
// Массив приводится к строке 'NaNba, CC'
// Канкатинация строк 'b' + ['NaNba', 'CC'] => 'bNaNba, CC'
// При разности не числовых значений будет NaN


[] + (() => { });
// [] преобразуется в строку ""
// (()=>{}) => ()=>{}
// "" + ()=>{} => "()=>{}"


[] + (() => ({}));
//  []=>""
//  (()=>({})) => ()=>({})
//  "" + ()=>({}) => "()=>({})"


[] + (() => ({}))();
// [] => ""
// (()=>({}))() => {}
//  [] + {} => "" + [object Object] => "[object Object]"

[] + (() => new Object(123))()
// (() => new Object(123))() => Number {123}
// Number {123} будет преобразован к примитиву 123
//  [] => ""
// "" + 123 => "123"

{ } + (() => new Object(123))()
    // {} воспринимается как блок кода
    // (() => new Object(123))() => Number {123} => 123
    // Результат 123



    (() => new Object(123))() + {}
        // левая часть будет приведена к примитиву 123
        // правая к "[object Object]"
        // 123 + "[object Object]" => "123[object Object]"


        ({}).valueOf() + 1
// ({}).valueOf() => {} => "[object Object]"
// "[object Object]" + 1 => "[object Object]1"


{ } + 2
// {} => пустой блок кода
// результат 2



typeof ({}).valueOf() + 2
    + {}
    + {} + []
    + []
    + [] + {}
    + [10, 1] + {}
{ } +[10]